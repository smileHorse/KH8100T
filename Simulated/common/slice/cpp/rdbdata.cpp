// **********************************************************************
//
// Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.4
//
// <auto-generated>
//
// Generated from file `rdbdata.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <rdbdata.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/BasicStream.h>
#include <IceUtil/Iterator.h>
#include <IceUtil/PopDisableWarnings.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 306
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 4
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __RdbRealData__RdbRealDataRequest__RequestDefaultData_name = "RequestDefaultData";

const ::std::string __RdbRealData__RdbRealDataRequest__RequestSpecificData_name = "RequestSpecificData";

const ::std::string __RdbRealData__RdbRealDataRequest__RequestCompleteData_name = "RequestCompleteData";

const ::std::string __RdbRealData__RdbRealDataRequest__SendTopoDataRequest_name = "SendTopoDataRequest";

const ::std::string __RdbRealData__RdbRealDataRespond__RespondDefaultData_name = "RespondDefaultData";

const ::std::string __RdbRealData__RdbRealDataRespond__RespondSpecificData_name = "RespondSpecificData";

const ::std::string __RdbRealData__RdbRealDataRespond__RespondCompleteData_name = "RespondCompleteData";

const ::std::string __RdbRealData__RdbRealDataRespond__SendTopoDataRespond_name = "SendTopoDataRespond";

const ::std::string __RdbRealData__RdbDataOpt__InsertData_name = "InsertData";

const ::std::string __RdbRealData__RdbDataOpt__SelectDefaultData_name = "SelectDefaultData";

const ::std::string __RdbRealData__RdbDataOpt__SelectSpecificData_name = "SelectSpecificData";

const ::std::string __RdbRealData__RdbDataOpt__SelectCompleteData_name = "SelectCompleteData";

const ::std::string __RdbRealData__RdbDataOpt__BatchSelectCompleteData_name = "BatchSelectCompleteData";

const ::std::string __RdbRealData__RdbDataOpt__SelectDataWithCondition_name = "SelectDataWithCondition";

const ::std::string __RdbRealData__RdbDataOpt__SelectDataCount_name = "SelectDataCount";

const ::std::string __RdbRealData__RdbDataOpt__UpdateCompleteData_name = "UpdateCompleteData";

const ::std::string __RdbRealData__RdbDataOpt__DeleteRdbData_name = "DeleteRdbData";

const ::std::string __RdbRealData__RdbDataOpt__GetEquipTree_name = "GetEquipTree";

const ::std::string __RdbRealData__RdbDataOpt__GetSpecificEquipTree_name = "GetSpecificEquipTree";

const ::std::string __RdbRealData__RdbDataOpt__GetEquipLineAndStationInfo_name = "GetEquipLineAndStationInfo";

const ::std::string __RdbRealData__RdbDataOpt__isOrphanNode_name = "isOrphanNode";

const ::std::string __RdbRealData__RdbDataOpt__isEmptyNode_name = "isEmptyNode";

const ::std::string __RdbRealData__RdbDataOpt__IsInvalidDbData_name = "IsInvalidDbData";

const ::std::string __RdbRealData__RdbDataOpt__GetTopoData_name = "GetTopoData";

const ::std::string __RdbRealData__RdbDataOpt__GetTopoIslandInfo_name = "GetTopoIslandInfo";

const ::std::string __RdbRealData__RdbDataOpt__UpdateTopoData_name = "UpdateTopoData";

const ::std::string __RdbRealData__RdbDataOpt__GetSectionData_name = "GetSectionData";

const ::std::string __RdbRealData__RdbDataOpt__GetAllSectionData_name = "GetAllSectionData";

const ::std::string __RdbRealData__RdbDataOpt__updateBreaker_name = "updateBreaker";

const ::std::string __RdbRealData__RdbDataOpt__updateDisconnector_name = "updateDisconnector";

const ::std::string __RdbRealData__RdbDataOpt__updatePowerTransformer_name = "updatePowerTransformer";

const ::std::string __RdbRealData__RdbDataOpt__updateAnalog_name = "updateAnalog";

const ::std::string __RdbRealData__RdbDataOpt__updateDiscrete_name = "updateDiscrete";

const ::std::string __RdbRealData__RdbDataOpt__updateAccumulator_name = "updateAccumulator";

const ::std::string __RdbRealData__RdbDataOpt__updateRemoteUnit_name = "updateRemoteUnit";

const ::std::string __RdbRealData__RdbDataOpt__getCurvePointDataSeq_name = "getCurvePointDataSeq";

}

namespace
{

const ::std::string __RdbWarningData__RdbAlarmData__SendAlarmData_name = "SendAlarmData";

const ::std::string __RdbWarningData__RdbAllAlarmData__SendAllAlarmData_name = "SendAllAlarmData";

const ::std::string __RdbWarningData__RdbWarningBuf__SendOutAnalogWarningBufs_name = "SendOutAnalogWarningBufs";

const ::std::string __RdbWarningData__RdbWarningBuf__SendChangedUnitWarningBufs_name = "SendChangedUnitWarningBufs";

const ::std::string __RdbWarningData__RdbWarningBuf__SendChangedChannelWarningBufs_name = "SendChangedChannelWarningBufs";

}

namespace Ice
{
}

namespace Ice
{
}
::IceProxy::Ice::Object* ::IceProxy::RdbRealData::upCast(::IceProxy::RdbRealData::RdbRealDataRequest* p) { return p; }

void
::IceProxy::RdbRealData::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::RdbRealData::RdbRealDataRequest>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::RdbRealData::RdbRealDataRequest;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::RdbRealData::RdbRealDataRequest::RequestDefaultData(const ::RdbRealData::RequestDefaultDataSeq& __p_seq, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbRealDataRequest__RequestDefaultData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbRealDataRequest::begin_RequestDefaultData(const ::RdbRealData::RequestDefaultDataSeq& __p_seq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbRealDataRequest__RequestDefaultData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbRealDataRequest__RequestDefaultData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::RdbRealData::RdbRealDataRequest::end_RequestDefaultData(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RdbRealData__RdbRealDataRequest__RequestDefaultData_name);
}

void
IceProxy::RdbRealData::RdbRealDataRequest::RequestSpecificData(const ::RdbRealData::RequestSpecficDataSeq& __p_seq, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbRealDataRequest__RequestSpecificData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbRealDataRequest::begin_RequestSpecificData(const ::RdbRealData::RequestSpecficDataSeq& __p_seq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbRealDataRequest__RequestSpecificData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbRealDataRequest__RequestSpecificData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::RdbRealData::RdbRealDataRequest::end_RequestSpecificData(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RdbRealData__RdbRealDataRequest__RequestSpecificData_name);
}

void
IceProxy::RdbRealData::RdbRealDataRequest::RequestCompleteData(const ::RdbRealData::RequestCompleteDataSeq& __p_seq, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbRealDataRequest__RequestCompleteData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbRealDataRequest::begin_RequestCompleteData(const ::RdbRealData::RequestCompleteDataSeq& __p_seq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbRealDataRequest__RequestCompleteData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbRealDataRequest__RequestCompleteData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::RdbRealData::RdbRealDataRequest::end_RequestCompleteData(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RdbRealData__RdbRealDataRequest__RequestCompleteData_name);
}

void
IceProxy::RdbRealData::RdbRealDataRequest::SendTopoDataRequest(const ::RdbRealData::RequestTopoDataSeq& __p_seq, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbRealDataRequest__SendTopoDataRequest_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbRealDataRequest::begin_SendTopoDataRequest(const ::RdbRealData::RequestTopoDataSeq& __p_seq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbRealDataRequest__SendTopoDataRequest_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbRealDataRequest__SendTopoDataRequest_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::RdbRealData::RdbRealDataRequest::end_SendTopoDataRequest(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RdbRealData__RdbRealDataRequest__SendTopoDataRequest_name);
}

const ::std::string&
IceProxy::RdbRealData::RdbRealDataRequest::ice_staticId()
{
    return ::RdbRealData::RdbRealDataRequest::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::RdbRealData::RdbRealDataRequest::__newInstance() const
{
    return new RdbRealDataRequest;
}
::IceProxy::Ice::Object* ::IceProxy::RdbRealData::upCast(::IceProxy::RdbRealData::RdbRealDataRespond* p) { return p; }

void
::IceProxy::RdbRealData::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::RdbRealData::RdbRealDataRespond>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::RdbRealData::RdbRealDataRespond;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::RdbRealData::RdbRealDataRespond::RespondDefaultData(const ::RdbRealData::RespondDefaultDataSeq& __p_seq, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbRealDataRespond__RespondDefaultData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbRealDataRespond::begin_RespondDefaultData(const ::RdbRealData::RespondDefaultDataSeq& __p_seq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbRealDataRespond__RespondDefaultData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbRealDataRespond__RespondDefaultData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::RdbRealData::RdbRealDataRespond::end_RespondDefaultData(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RdbRealData__RdbRealDataRespond__RespondDefaultData_name);
}

void
IceProxy::RdbRealData::RdbRealDataRespond::RespondSpecificData(const ::RdbRealData::RespondSpecficDataSeq& __p_seq, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbRealDataRespond__RespondSpecificData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbRealDataRespond::begin_RespondSpecificData(const ::RdbRealData::RespondSpecficDataSeq& __p_seq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbRealDataRespond__RespondSpecificData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbRealDataRespond__RespondSpecificData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::RdbRealData::RdbRealDataRespond::end_RespondSpecificData(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RdbRealData__RdbRealDataRespond__RespondSpecificData_name);
}

void
IceProxy::RdbRealData::RdbRealDataRespond::RespondCompleteData(const ::RdbRealData::RespondCompleteDataSeq& __p_seq, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbRealDataRespond__RespondCompleteData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbRealDataRespond::begin_RespondCompleteData(const ::RdbRealData::RespondCompleteDataSeq& __p_seq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbRealDataRespond__RespondCompleteData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbRealDataRespond__RespondCompleteData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::RdbRealData::RdbRealDataRespond::end_RespondCompleteData(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RdbRealData__RdbRealDataRespond__RespondCompleteData_name);
}

void
IceProxy::RdbRealData::RdbRealDataRespond::SendTopoDataRespond(const ::RdbRealData::ReceiveTopoDataSeq& __p_seq, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbRealDataRespond__SendTopoDataRespond_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbRealDataRespond::begin_SendTopoDataRespond(const ::RdbRealData::ReceiveTopoDataSeq& __p_seq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbRealDataRespond__SendTopoDataRespond_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbRealDataRespond__SendTopoDataRespond_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::RdbRealData::RdbRealDataRespond::end_SendTopoDataRespond(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RdbRealData__RdbRealDataRespond__SendTopoDataRespond_name);
}

const ::std::string&
IceProxy::RdbRealData::RdbRealDataRespond::ice_staticId()
{
    return ::RdbRealData::RdbRealDataRespond::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::RdbRealData::RdbRealDataRespond::__newInstance() const
{
    return new RdbRealDataRespond;
}
::IceProxy::Ice::Object* ::IceProxy::RdbRealData::upCast(::IceProxy::RdbRealData::RdbDataOpt* p) { return p; }

void
::IceProxy::RdbRealData::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::RdbRealData::RdbDataOpt>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::RdbRealData::RdbDataOpt;
        v->__copyFrom(proxy);
    }
}

bool
IceProxy::RdbRealData::RdbDataOpt::InsertData(const ::RdbRealData::RespondCompleteDataSeq& __p_dataSeq, ::RdbRealData::RespondCompleteDataSequence& __p_errorSeq, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__InsertData_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__InsertData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_dataSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_errorSeq);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_InsertData(const ::RdbRealData::RespondCompleteDataSeq& __p_dataSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__InsertData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__InsertData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__InsertData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_dataSeq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_InsertData(const ::RdbRealData::RespondCompleteDataSeq& __p_dataSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::RdbRealData::RespondCompleteDataSequence&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::RdbRealData::RespondCompleteDataSequence&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            ::RdbRealData::RespondCompleteDataSequence __p_errorSeq;
            bool __ret;
            try
            {
                __ret = __proxy->end_InsertData(__p_errorSeq, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_errorSeq);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::RdbRealData::RespondCompleteDataSequence&)> _response;
    };
    return begin_InsertData(__p_dataSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_InsertData(::RdbRealData::RespondCompleteDataSequence& __p_errorSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__InsertData_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_errorSeq);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::SelectDefaultData(const ::RdbRealData::RequestDefaultDataSeq& __p_reqSeq, ::RdbRealData::RespondDefaultDataSeq& __p_repSeq, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__SelectDefaultData_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__SelectDefaultData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_reqSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_repSeq);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_SelectDefaultData(const ::RdbRealData::RequestDefaultDataSeq& __p_reqSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__SelectDefaultData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__SelectDefaultData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__SelectDefaultData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_reqSeq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_SelectDefaultData(const ::RdbRealData::RequestDefaultDataSeq& __p_reqSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::RdbRealData::RespondDefaultDataSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::RdbRealData::RespondDefaultDataSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            ::RdbRealData::RespondDefaultDataSeq __p_repSeq;
            bool __ret;
            try
            {
                __ret = __proxy->end_SelectDefaultData(__p_repSeq, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_repSeq);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::RdbRealData::RespondDefaultDataSeq&)> _response;
    };
    return begin_SelectDefaultData(__p_reqSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_SelectDefaultData(::RdbRealData::RespondDefaultDataSeq& __p_repSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__SelectDefaultData_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_repSeq);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::SelectSpecificData(const ::RdbRealData::RequestSpecficDataSeq& __p_reqSeq, ::RdbRealData::RespondSpecficDataSeq& __p_repSeq, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__SelectSpecificData_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__SelectSpecificData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_reqSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_repSeq);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_SelectSpecificData(const ::RdbRealData::RequestSpecficDataSeq& __p_reqSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__SelectSpecificData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__SelectSpecificData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__SelectSpecificData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_reqSeq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_SelectSpecificData(const ::RdbRealData::RequestSpecficDataSeq& __p_reqSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::RdbRealData::RespondSpecficDataSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::RdbRealData::RespondSpecficDataSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            ::RdbRealData::RespondSpecficDataSeq __p_repSeq;
            bool __ret;
            try
            {
                __ret = __proxy->end_SelectSpecificData(__p_repSeq, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_repSeq);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::RdbRealData::RespondSpecficDataSeq&)> _response;
    };
    return begin_SelectSpecificData(__p_reqSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_SelectSpecificData(::RdbRealData::RespondSpecficDataSeq& __p_repSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__SelectSpecificData_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_repSeq);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::SelectCompleteData(const ::RdbRealData::RequestCompleteDataSeq& __p_reqSeq, ::RdbRealData::RespondCompleteDataSeq& __p_repSeq, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__SelectCompleteData_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__SelectCompleteData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_reqSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_repSeq);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_SelectCompleteData(const ::RdbRealData::RequestCompleteDataSeq& __p_reqSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__SelectCompleteData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__SelectCompleteData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__SelectCompleteData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_reqSeq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_SelectCompleteData(const ::RdbRealData::RequestCompleteDataSeq& __p_reqSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::RdbRealData::RespondCompleteDataSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::RdbRealData::RespondCompleteDataSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            ::RdbRealData::RespondCompleteDataSeq __p_repSeq;
            bool __ret;
            try
            {
                __ret = __proxy->end_SelectCompleteData(__p_repSeq, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_repSeq);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::RdbRealData::RespondCompleteDataSeq&)> _response;
    };
    return begin_SelectCompleteData(__p_reqSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_SelectCompleteData(::RdbRealData::RespondCompleteDataSeq& __p_repSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__SelectCompleteData_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_repSeq);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::BatchSelectCompleteData(const ::RdbRealData::BatchRequestCompleteDataSeq& __p_reqSeq, ::RdbRealData::RespondCompleteDataSeq& __p_repSeq, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__BatchSelectCompleteData_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__BatchSelectCompleteData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_reqSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_repSeq);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_BatchSelectCompleteData(const ::RdbRealData::BatchRequestCompleteDataSeq& __p_reqSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__BatchSelectCompleteData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__BatchSelectCompleteData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__BatchSelectCompleteData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_reqSeq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_BatchSelectCompleteData(const ::RdbRealData::BatchRequestCompleteDataSeq& __p_reqSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::RdbRealData::RespondCompleteDataSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::RdbRealData::RespondCompleteDataSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            ::RdbRealData::RespondCompleteDataSeq __p_repSeq;
            bool __ret;
            try
            {
                __ret = __proxy->end_BatchSelectCompleteData(__p_repSeq, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_repSeq);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::RdbRealData::RespondCompleteDataSeq&)> _response;
    };
    return begin_BatchSelectCompleteData(__p_reqSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_BatchSelectCompleteData(::RdbRealData::RespondCompleteDataSeq& __p_repSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__BatchSelectCompleteData_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_repSeq);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::SelectDataWithCondition(const ::RdbRealData::RequestConditionSequence& __p_reqSeq, ::RdbRealData::RespondCompleteDataSeq& __p_repSeq, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__SelectDataWithCondition_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__SelectDataWithCondition_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_reqSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_repSeq);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_SelectDataWithCondition(const ::RdbRealData::RequestConditionSequence& __p_reqSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__SelectDataWithCondition_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__SelectDataWithCondition_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__SelectDataWithCondition_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_reqSeq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_SelectDataWithCondition(const ::RdbRealData::RequestConditionSequence& __p_reqSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::RdbRealData::RespondCompleteDataSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::RdbRealData::RespondCompleteDataSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            ::RdbRealData::RespondCompleteDataSeq __p_repSeq;
            bool __ret;
            try
            {
                __ret = __proxy->end_SelectDataWithCondition(__p_repSeq, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_repSeq);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::RdbRealData::RespondCompleteDataSeq&)> _response;
    };
    return begin_SelectDataWithCondition(__p_reqSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_SelectDataWithCondition(::RdbRealData::RespondCompleteDataSeq& __p_repSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__SelectDataWithCondition_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_repSeq);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::SelectDataCount(const ::RdbRealData::RequestDefaultDataSeq& __p_reqSeq, ::RdbRealData::RespondDataCountSequence& __p_repSeq, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__SelectDataCount_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__SelectDataCount_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_reqSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_repSeq);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_SelectDataCount(const ::RdbRealData::RequestDefaultDataSeq& __p_reqSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__SelectDataCount_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__SelectDataCount_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__SelectDataCount_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_reqSeq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_SelectDataCount(const ::RdbRealData::RequestDefaultDataSeq& __p_reqSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::RdbRealData::RespondDataCountSequence&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::RdbRealData::RespondDataCountSequence&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            ::RdbRealData::RespondDataCountSequence __p_repSeq;
            bool __ret;
            try
            {
                __ret = __proxy->end_SelectDataCount(__p_repSeq, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_repSeq);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::RdbRealData::RespondDataCountSequence&)> _response;
    };
    return begin_SelectDataCount(__p_reqSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_SelectDataCount(::RdbRealData::RespondDataCountSequence& __p_repSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__SelectDataCount_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_repSeq);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::UpdateCompleteData(const ::RdbRealData::RespondCompleteDataSeq& __p_reqSeq, ::RdbRealData::RespondCompleteDataSequence& __p_repSeq, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__UpdateCompleteData_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__UpdateCompleteData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_reqSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_repSeq);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_UpdateCompleteData(const ::RdbRealData::RespondCompleteDataSeq& __p_reqSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__UpdateCompleteData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__UpdateCompleteData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__UpdateCompleteData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_reqSeq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_UpdateCompleteData(const ::RdbRealData::RespondCompleteDataSeq& __p_reqSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::RdbRealData::RespondCompleteDataSequence&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::RdbRealData::RespondCompleteDataSequence&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            ::RdbRealData::RespondCompleteDataSequence __p_repSeq;
            bool __ret;
            try
            {
                __ret = __proxy->end_UpdateCompleteData(__p_repSeq, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_repSeq);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::RdbRealData::RespondCompleteDataSequence&)> _response;
    };
    return begin_UpdateCompleteData(__p_reqSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_UpdateCompleteData(::RdbRealData::RespondCompleteDataSequence& __p_repSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__UpdateCompleteData_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_repSeq);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::DeleteRdbData(const ::RdbRealData::RequestDefaultDataSeq& __p_dataSeq, ::RdbRealData::RequestDefaultDataSequence& __p_errorSeq, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__DeleteRdbData_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__DeleteRdbData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_dataSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_errorSeq);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_DeleteRdbData(const ::RdbRealData::RequestDefaultDataSeq& __p_dataSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__DeleteRdbData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__DeleteRdbData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__DeleteRdbData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_dataSeq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_DeleteRdbData(const ::RdbRealData::RequestDefaultDataSeq& __p_dataSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::RdbRealData::RequestDefaultDataSequence&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::RdbRealData::RequestDefaultDataSequence&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            ::RdbRealData::RequestDefaultDataSequence __p_errorSeq;
            bool __ret;
            try
            {
                __ret = __proxy->end_DeleteRdbData(__p_errorSeq, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_errorSeq);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::RdbRealData::RequestDefaultDataSequence&)> _response;
    };
    return begin_DeleteRdbData(__p_dataSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_DeleteRdbData(::RdbRealData::RequestDefaultDataSequence& __p_errorSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__DeleteRdbData_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_errorSeq);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::GetEquipTree(const ::std::string& __p_deviceType, const ::std::string& __p_deviceRid, ::RdbRealData::EquipTreeSequence& __p_treeSeq, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__GetEquipTree_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__GetEquipTree_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceType);
        __os->write(__p_deviceRid);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_treeSeq);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_GetEquipTree(const ::std::string& __p_deviceType, const ::std::string& __p_deviceRid, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__GetEquipTree_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__GetEquipTree_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__GetEquipTree_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceType);
        __os->write(__p_deviceRid);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_GetEquipTree(const ::std::string& __p_deviceType, const ::std::string& __p_deviceRid, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::RdbRealData::EquipTreeSequence&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::RdbRealData::EquipTreeSequence&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            ::RdbRealData::EquipTreeSequence __p_treeSeq;
            bool __ret;
            try
            {
                __ret = __proxy->end_GetEquipTree(__p_treeSeq, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_treeSeq);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::RdbRealData::EquipTreeSequence&)> _response;
    };
    return begin_GetEquipTree(__p_deviceType, __p_deviceRid, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_GetEquipTree(::RdbRealData::EquipTreeSequence& __p_treeSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__GetEquipTree_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_treeSeq);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::GetSpecificEquipTree(const ::std::string& __p_deviceType, const ::std::string& __p_deviceRid, const ::std::string& __p_specDeviceType, ::RdbRealData::EquipTreeSequence& __p_treeSeq, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__GetSpecificEquipTree_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__GetSpecificEquipTree_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceType);
        __os->write(__p_deviceRid);
        __os->write(__p_specDeviceType);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_treeSeq);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_GetSpecificEquipTree(const ::std::string& __p_deviceType, const ::std::string& __p_deviceRid, const ::std::string& __p_specDeviceType, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__GetSpecificEquipTree_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__GetSpecificEquipTree_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__GetSpecificEquipTree_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceType);
        __os->write(__p_deviceRid);
        __os->write(__p_specDeviceType);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_GetSpecificEquipTree(const ::std::string& __p_deviceType, const ::std::string& __p_deviceRid, const ::std::string& __p_specDeviceType, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::RdbRealData::EquipTreeSequence&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::RdbRealData::EquipTreeSequence&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            ::RdbRealData::EquipTreeSequence __p_treeSeq;
            bool __ret;
            try
            {
                __ret = __proxy->end_GetSpecificEquipTree(__p_treeSeq, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_treeSeq);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::RdbRealData::EquipTreeSequence&)> _response;
    };
    return begin_GetSpecificEquipTree(__p_deviceType, __p_deviceRid, __p_specDeviceType, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_GetSpecificEquipTree(::RdbRealData::EquipTreeSequence& __p_treeSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__GetSpecificEquipTree_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_treeSeq);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::GetEquipLineAndStationInfo(const ::std::string& __p_deviceType, const ::std::string& __p_deviceRid, ::RdbRealData::LineAndStationInfo& __p_info, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__GetEquipLineAndStationInfo_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__GetEquipLineAndStationInfo_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceType);
        __os->write(__p_deviceRid);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_info);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_GetEquipLineAndStationInfo(const ::std::string& __p_deviceType, const ::std::string& __p_deviceRid, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__GetEquipLineAndStationInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__GetEquipLineAndStationInfo_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__GetEquipLineAndStationInfo_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceType);
        __os->write(__p_deviceRid);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_GetEquipLineAndStationInfo(const ::std::string& __p_deviceType, const ::std::string& __p_deviceRid, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::RdbRealData::LineAndStationInfo&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::RdbRealData::LineAndStationInfo&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            ::RdbRealData::LineAndStationInfo __p_info;
            bool __ret;
            try
            {
                __ret = __proxy->end_GetEquipLineAndStationInfo(__p_info, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_info);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::RdbRealData::LineAndStationInfo&)> _response;
    };
    return begin_GetEquipLineAndStationInfo(__p_deviceType, __p_deviceRid, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_GetEquipLineAndStationInfo(::RdbRealData::LineAndStationInfo& __p_info, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__GetEquipLineAndStationInfo_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_info);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::isOrphanNode(const ::std::string& __p_dataType, const ::std::string& __p_dataRid, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__isOrphanNode_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__isOrphanNode_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_dataType);
        __os->write(__p_dataRid);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_isOrphanNode(const ::std::string& __p_dataType, const ::std::string& __p_dataRid, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__isOrphanNode_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__isOrphanNode_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__isOrphanNode_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_dataType);
        __os->write(__p_dataRid);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_isOrphanNode(const ::std::string& __p_dataType, const ::std::string& __p_dataRid, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_isOrphanNode(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_isOrphanNode(__p_dataType, __p_dataRid, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_isOrphanNode(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__isOrphanNode_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::isEmptyNode(const ::std::string& __p_dataType, const ::std::string& __p_dataRid, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__isEmptyNode_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__isEmptyNode_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_dataType);
        __os->write(__p_dataRid);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_isEmptyNode(const ::std::string& __p_dataType, const ::std::string& __p_dataRid, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__isEmptyNode_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__isEmptyNode_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__isEmptyNode_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_dataType);
        __os->write(__p_dataRid);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_isEmptyNode(const ::std::string& __p_dataType, const ::std::string& __p_dataRid, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_isEmptyNode(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_isEmptyNode(__p_dataType, __p_dataRid, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_isEmptyNode(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__isEmptyNode_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::IsInvalidDbData(const ::std::string& __p_tableName, const ::std::string& __p_dataRID, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__IsInvalidDbData_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__IsInvalidDbData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_tableName);
        __os->write(__p_dataRID);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_IsInvalidDbData(const ::std::string& __p_tableName, const ::std::string& __p_dataRID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__IsInvalidDbData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__IsInvalidDbData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__IsInvalidDbData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_tableName);
        __os->write(__p_dataRID);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_IsInvalidDbData(const ::std::string& __p_tableName, const ::std::string& __p_dataRID, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_IsInvalidDbData(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_IsInvalidDbData(__p_tableName, __p_dataRID, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_IsInvalidDbData(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__IsInvalidDbData_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::GetTopoData(const ::RdbRealData::RequestTopoDataSeq& __p_inDataSeq, ::RdbRealData::ReceiveTopoDataSeq& __p_outDataSeq, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__GetTopoData_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__GetTopoData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_inDataSeq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_outDataSeq);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_GetTopoData(const ::RdbRealData::RequestTopoDataSeq& __p_inDataSeq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__GetTopoData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__GetTopoData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__GetTopoData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_inDataSeq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_GetTopoData(const ::RdbRealData::RequestTopoDataSeq& __p_inDataSeq, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::RdbRealData::ReceiveTopoDataSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::RdbRealData::ReceiveTopoDataSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            ::RdbRealData::ReceiveTopoDataSeq __p_outDataSeq;
            bool __ret;
            try
            {
                __ret = __proxy->end_GetTopoData(__p_outDataSeq, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_outDataSeq);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::RdbRealData::ReceiveTopoDataSeq&)> _response;
    };
    return begin_GetTopoData(__p_inDataSeq, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_GetTopoData(::RdbRealData::ReceiveTopoDataSeq& __p_outDataSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__GetTopoData_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_outDataSeq);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::RdbRealData::RdbDataOpt::GetTopoIslandInfo(::RdbRealData::TopoIslandInfoSeq& __p_islandInfoes, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__GetTopoIslandInfo_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__GetTopoIslandInfo_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_islandInfoes);
    __og.endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_GetTopoIslandInfo(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__GetTopoIslandInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__GetTopoIslandInfo_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__GetTopoIslandInfo_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_GetTopoIslandInfo(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::RdbRealData::TopoIslandInfoSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::RdbRealData::TopoIslandInfoSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            ::RdbRealData::TopoIslandInfoSeq __p_islandInfoes;
            try
            {
                __proxy->end_GetTopoIslandInfo(__p_islandInfoes, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__p_islandInfoes);
            }
        }
    
    private:
        
        ::std::function<void (const ::RdbRealData::TopoIslandInfoSeq&)> _response;
    };
    return begin_GetTopoIslandInfo(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::RdbRealData::RdbDataOpt::end_GetTopoIslandInfo(::RdbRealData::TopoIslandInfoSeq& __p_islandInfoes, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__GetTopoIslandInfo_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_islandInfoes);
    __result->__endReadParams();
}

void
IceProxy::RdbRealData::RdbDataOpt::UpdateTopoData(const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__UpdateTopoData_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_UpdateTopoData(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__UpdateTopoData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__UpdateTopoData_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::RdbRealData::RdbDataOpt::end_UpdateTopoData(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RdbRealData__RdbDataOpt__UpdateTopoData_name);
}

bool
IceProxy::RdbRealData::RdbDataOpt::GetSectionData(const ::std::string& __p_deviceRid, ::RdbRealData::DoubleSeq& __p_analogValues, ::RdbRealData::IntegerSeq& __p_discreteValues, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__GetSectionData_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__GetSectionData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceRid);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_analogValues);
    __is->read(__p_discreteValues);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_GetSectionData(const ::std::string& __p_deviceRid, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__GetSectionData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__GetSectionData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__GetSectionData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceRid);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_GetSectionData(const ::std::string& __p_deviceRid, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::RdbRealData::DoubleSeq&, const ::RdbRealData::IntegerSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::RdbRealData::DoubleSeq&, const ::RdbRealData::IntegerSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            ::RdbRealData::DoubleSeq __p_analogValues;
            ::RdbRealData::IntegerSeq __p_discreteValues;
            bool __ret;
            try
            {
                __ret = __proxy->end_GetSectionData(__p_analogValues, __p_discreteValues, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_analogValues, __p_discreteValues);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::RdbRealData::DoubleSeq&, const ::RdbRealData::IntegerSeq&)> _response;
    };
    return begin_GetSectionData(__p_deviceRid, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_GetSectionData(::RdbRealData::DoubleSeq& __p_analogValues, ::RdbRealData::IntegerSeq& __p_discreteValues, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__GetSectionData_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_analogValues);
    __is->read(__p_discreteValues);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::GetAllSectionData(const ::std::string& __p_deviceRid, ::RdbRealData::SectionValueSeq& __p_analogValues, ::RdbRealData::IntegerSeq& __p_discreteValues, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__GetAllSectionData_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__GetAllSectionData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceRid);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_analogValues);
    __is->read(__p_discreteValues);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_GetAllSectionData(const ::std::string& __p_deviceRid, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__GetAllSectionData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__GetAllSectionData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__GetAllSectionData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceRid);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_GetAllSectionData(const ::std::string& __p_deviceRid, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::RdbRealData::SectionValueSeq&, const ::RdbRealData::IntegerSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::RdbRealData::SectionValueSeq&, const ::RdbRealData::IntegerSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            ::RdbRealData::SectionValueSeq __p_analogValues;
            ::RdbRealData::IntegerSeq __p_discreteValues;
            bool __ret;
            try
            {
                __ret = __proxy->end_GetAllSectionData(__p_analogValues, __p_discreteValues, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_analogValues, __p_discreteValues);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::RdbRealData::SectionValueSeq&, const ::RdbRealData::IntegerSeq&)> _response;
    };
    return begin_GetAllSectionData(__p_deviceRid, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_GetAllSectionData(::RdbRealData::SectionValueSeq& __p_analogValues, ::RdbRealData::IntegerSeq& __p_discreteValues, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__GetAllSectionData_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_analogValues);
    __is->read(__p_discreteValues);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::updateBreaker(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__updateBreaker_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__updateBreaker_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_mrid);
        __os->write(__p_fieldData);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_updateBreaker(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__updateBreaker_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__updateBreaker_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__updateBreaker_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_mrid);
        __os->write(__p_fieldData);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_updateBreaker(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_updateBreaker(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_updateBreaker(__p_mrid, __p_fieldData, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_updateBreaker(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__updateBreaker_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::updateDisconnector(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__updateDisconnector_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__updateDisconnector_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_mrid);
        __os->write(__p_fieldData);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_updateDisconnector(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__updateDisconnector_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__updateDisconnector_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__updateDisconnector_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_mrid);
        __os->write(__p_fieldData);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_updateDisconnector(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_updateDisconnector(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_updateDisconnector(__p_mrid, __p_fieldData, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_updateDisconnector(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__updateDisconnector_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::updatePowerTransformer(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__updatePowerTransformer_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__updatePowerTransformer_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_mrid);
        __os->write(__p_fieldData);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_updatePowerTransformer(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__updatePowerTransformer_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__updatePowerTransformer_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__updatePowerTransformer_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_mrid);
        __os->write(__p_fieldData);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_updatePowerTransformer(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_updatePowerTransformer(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_updatePowerTransformer(__p_mrid, __p_fieldData, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_updatePowerTransformer(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__updatePowerTransformer_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::updateAnalog(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__updateAnalog_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__updateAnalog_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_mrid);
        __os->write(__p_fieldData);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_updateAnalog(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__updateAnalog_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__updateAnalog_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__updateAnalog_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_mrid);
        __os->write(__p_fieldData);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_updateAnalog(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_updateAnalog(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_updateAnalog(__p_mrid, __p_fieldData, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_updateAnalog(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__updateAnalog_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::updateDiscrete(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__updateDiscrete_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__updateDiscrete_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_mrid);
        __os->write(__p_fieldData);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_updateDiscrete(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__updateDiscrete_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__updateDiscrete_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__updateDiscrete_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_mrid);
        __os->write(__p_fieldData);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_updateDiscrete(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_updateDiscrete(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_updateDiscrete(__p_mrid, __p_fieldData, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_updateDiscrete(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__updateDiscrete_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::updateAccumulator(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__updateAccumulator_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__updateAccumulator_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_mrid);
        __os->write(__p_fieldData);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_updateAccumulator(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__updateAccumulator_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__updateAccumulator_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__updateAccumulator_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_mrid);
        __os->write(__p_fieldData);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_updateAccumulator(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_updateAccumulator(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_updateAccumulator(__p_mrid, __p_fieldData, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_updateAccumulator(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__updateAccumulator_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::updateRemoteUnit(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__updateRemoteUnit_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__updateRemoteUnit_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_mrid);
        __os->write(__p_fieldData);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_updateRemoteUnit(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__updateRemoteUnit_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__updateRemoteUnit_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__updateRemoteUnit_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_mrid);
        __os->write(__p_fieldData);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_updateRemoteUnit(const ::std::string& __p_mrid, const ::RdbRealData::FieldMap& __p_fieldData, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_updateRemoteUnit(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_updateRemoteUnit(__p_mrid, __p_fieldData, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_updateRemoteUnit(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__updateRemoteUnit_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::RdbRealData::RdbDataOpt::getCurvePointDataSeq(const ::RdbRealData::Strings& __p_analogs, ::RdbRealData::CurvePointDataSeq& __p_dataSeq, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__RdbRealData__RdbDataOpt__getCurvePointDataSeq_name);
    ::IceInternal::Outgoing __og(this, __RdbRealData__RdbDataOpt__getCurvePointDataSeq_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_analogs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_dataSeq);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::begin_getCurvePointDataSeq(const ::RdbRealData::Strings& __p_analogs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RdbRealData__RdbDataOpt__getCurvePointDataSeq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbRealData__RdbDataOpt__getCurvePointDataSeq_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbRealData__RdbDataOpt__getCurvePointDataSeq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_analogs);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::RdbRealData::RdbDataOpt::__begin_getCurvePointDataSeq(const ::RdbRealData::Strings& __p_analogs, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::RdbRealData::CurvePointDataSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::RdbRealData::CurvePointDataSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::RdbRealData::RdbDataOptPrx __proxy = ::RdbRealData::RdbDataOptPrx::uncheckedCast(__result->getProxy());
            ::RdbRealData::CurvePointDataSeq __p_dataSeq;
            bool __ret;
            try
            {
                __ret = __proxy->end_getCurvePointDataSeq(__p_dataSeq, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_dataSeq);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::RdbRealData::CurvePointDataSeq&)> _response;
    };
    return begin_getCurvePointDataSeq(__p_analogs, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::RdbRealData::RdbDataOpt::end_getCurvePointDataSeq(::RdbRealData::CurvePointDataSeq& __p_dataSeq, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RdbRealData__RdbDataOpt__getCurvePointDataSeq_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_dataSeq);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

const ::std::string&
IceProxy::RdbRealData::RdbDataOpt::ice_staticId()
{
    return ::RdbRealData::RdbDataOpt::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::RdbRealData::RdbDataOpt::__newInstance() const
{
    return new RdbDataOpt;
}
::IceProxy::Ice::Object* ::IceProxy::RdbWarningData::upCast(::IceProxy::RdbWarningData::RdbAlarmData* p) { return p; }

void
::IceProxy::RdbWarningData::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::RdbWarningData::RdbAlarmData>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::RdbWarningData::RdbAlarmData;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::RdbWarningData::RdbAlarmData::SendAlarmData(const ::RdbWarningData::WarningInfoSeq& __p_seq, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __RdbWarningData__RdbAlarmData__SendAlarmData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::RdbWarningData::RdbAlarmData::begin_SendAlarmData(const ::RdbWarningData::WarningInfoSeq& __p_seq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbWarningData__RdbAlarmData__SendAlarmData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbWarningData__RdbAlarmData__SendAlarmData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::RdbWarningData::RdbAlarmData::end_SendAlarmData(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RdbWarningData__RdbAlarmData__SendAlarmData_name);
}

const ::std::string&
IceProxy::RdbWarningData::RdbAlarmData::ice_staticId()
{
    return ::RdbWarningData::RdbAlarmData::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::RdbWarningData::RdbAlarmData::__newInstance() const
{
    return new RdbAlarmData;
}
::IceProxy::Ice::Object* ::IceProxy::RdbWarningData::upCast(::IceProxy::RdbWarningData::RdbAllAlarmData* p) { return p; }

void
::IceProxy::RdbWarningData::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::RdbWarningData::RdbAllAlarmData>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::RdbWarningData::RdbAllAlarmData;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::RdbWarningData::RdbAllAlarmData::SendAllAlarmData(const ::RdbWarningData::WarningInfoSeq& __p_seq, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __RdbWarningData__RdbAllAlarmData__SendAllAlarmData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::RdbWarningData::RdbAllAlarmData::begin_SendAllAlarmData(const ::RdbWarningData::WarningInfoSeq& __p_seq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbWarningData__RdbAllAlarmData__SendAllAlarmData_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbWarningData__RdbAllAlarmData__SendAllAlarmData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::RdbWarningData::RdbAllAlarmData::end_SendAllAlarmData(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RdbWarningData__RdbAllAlarmData__SendAllAlarmData_name);
}

const ::std::string&
IceProxy::RdbWarningData::RdbAllAlarmData::ice_staticId()
{
    return ::RdbWarningData::RdbAllAlarmData::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::RdbWarningData::RdbAllAlarmData::__newInstance() const
{
    return new RdbAllAlarmData;
}
::IceProxy::Ice::Object* ::IceProxy::RdbWarningData::upCast(::IceProxy::RdbWarningData::RdbWarningBuf* p) { return p; }

void
::IceProxy::RdbWarningData::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::RdbWarningData::RdbWarningBuf>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::RdbWarningData::RdbWarningBuf;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::RdbWarningData::RdbWarningBuf::SendOutAnalogWarningBufs(const ::RdbWarningData::OutAnalogWarningBufSeq& __p_seq, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __RdbWarningData__RdbWarningBuf__SendOutAnalogWarningBufs_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::RdbWarningData::RdbWarningBuf::begin_SendOutAnalogWarningBufs(const ::RdbWarningData::OutAnalogWarningBufSeq& __p_seq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbWarningData__RdbWarningBuf__SendOutAnalogWarningBufs_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbWarningData__RdbWarningBuf__SendOutAnalogWarningBufs_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::RdbWarningData::RdbWarningBuf::end_SendOutAnalogWarningBufs(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RdbWarningData__RdbWarningBuf__SendOutAnalogWarningBufs_name);
}

void
IceProxy::RdbWarningData::RdbWarningBuf::SendChangedUnitWarningBufs(const ::RdbWarningData::ChangedUnitWarningBufSeq& __p_seq, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __RdbWarningData__RdbWarningBuf__SendChangedUnitWarningBufs_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::RdbWarningData::RdbWarningBuf::begin_SendChangedUnitWarningBufs(const ::RdbWarningData::ChangedUnitWarningBufSeq& __p_seq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbWarningData__RdbWarningBuf__SendChangedUnitWarningBufs_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbWarningData__RdbWarningBuf__SendChangedUnitWarningBufs_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::RdbWarningData::RdbWarningBuf::end_SendChangedUnitWarningBufs(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RdbWarningData__RdbWarningBuf__SendChangedUnitWarningBufs_name);
}

void
IceProxy::RdbWarningData::RdbWarningBuf::SendChangedChannelWarningBufs(const ::RdbWarningData::ChangedChannelWarningBufSeq& __p_seq, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __RdbWarningData__RdbWarningBuf__SendChangedChannelWarningBufs_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::RdbWarningData::RdbWarningBuf::begin_SendChangedChannelWarningBufs(const ::RdbWarningData::ChangedChannelWarningBufSeq& __p_seq, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RdbWarningData__RdbWarningBuf__SendChangedChannelWarningBufs_name, __del, __cookie);
    try
    {
        __result->prepare(__RdbWarningData__RdbWarningBuf__SendChangedChannelWarningBufs_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_seq);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::RdbWarningData::RdbWarningBuf::end_SendChangedChannelWarningBufs(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RdbWarningData__RdbWarningBuf__SendChangedChannelWarningBufs_name);
}

const ::std::string&
IceProxy::RdbWarningData::RdbWarningBuf::ice_staticId()
{
    return ::RdbWarningData::RdbWarningBuf::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::RdbWarningData::RdbWarningBuf::__newInstance() const
{
    return new RdbWarningBuf;
}

::Ice::Object* RdbRealData::upCast(::RdbRealData::RdbRealDataRequest* p) { return p; }

namespace
{
const ::std::string __RdbRealData__RdbRealDataRequest_ids[2] =
{
    "::Ice::Object",
    "::RdbRealData::RdbRealDataRequest"
};

}

bool
RdbRealData::RdbRealDataRequest::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__RdbRealData__RdbRealDataRequest_ids, __RdbRealData__RdbRealDataRequest_ids + 2, _s);
}

::std::vector< ::std::string>
RdbRealData::RdbRealDataRequest::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__RdbRealData__RdbRealDataRequest_ids[0], &__RdbRealData__RdbRealDataRequest_ids[2]);
}

const ::std::string&
RdbRealData::RdbRealDataRequest::ice_id(const ::Ice::Current&) const
{
    return __RdbRealData__RdbRealDataRequest_ids[1];
}

const ::std::string&
RdbRealData::RdbRealDataRequest::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::RdbRealData::RdbRealDataRequest";
    return typeId;
#else
    return __RdbRealData__RdbRealDataRequest_ids[1];
#endif
}

::Ice::DispatchStatus
RdbRealData::RdbRealDataRequest::___RequestDefaultData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::RequestDefaultDataSeq __p_seq;
    __is->read(__p_seq);
    __inS.endReadParams();
    RequestDefaultData(__p_seq, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbRealDataRequest::___RequestSpecificData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::RequestSpecficDataSeq __p_seq;
    __is->read(__p_seq);
    __inS.endReadParams();
    RequestSpecificData(__p_seq, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbRealDataRequest::___RequestCompleteData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::RequestCompleteDataSeq __p_seq;
    __is->read(__p_seq);
    __inS.endReadParams();
    RequestCompleteData(__p_seq, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbRealDataRequest::___SendTopoDataRequest(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::RequestTopoDataSeq __p_seq;
    __is->read(__p_seq);
    __inS.endReadParams();
    SendTopoDataRequest(__p_seq, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __RdbRealData__RdbRealDataRequest_all[] =
{
    "RequestCompleteData",
    "RequestDefaultData",
    "RequestSpecificData",
    "SendTopoDataRequest",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
RdbRealData::RdbRealDataRequest::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__RdbRealData__RdbRealDataRequest_all, __RdbRealData__RdbRealDataRequest_all + 8, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __RdbRealData__RdbRealDataRequest_all)
    {
        case 0:
        {
            return ___RequestCompleteData(in, current);
        }
        case 1:
        {
            return ___RequestDefaultData(in, current);
        }
        case 2:
        {
            return ___RequestSpecificData(in, current);
        }
        case 3:
        {
            return ___SendTopoDataRequest(in, current);
        }
        case 4:
        {
            return ___ice_id(in, current);
        }
        case 5:
        {
            return ___ice_ids(in, current);
        }
        case 6:
        {
            return ___ice_isA(in, current);
        }
        case 7:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
RdbRealData::RdbRealDataRequest::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
RdbRealData::RdbRealDataRequest::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
RdbRealData::__patch(RdbRealDataRequestPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::RdbRealData::RdbRealDataRequestPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::RdbRealData::RdbRealDataRequest::ice_staticId(), v);
    }
}

::Ice::Object* RdbRealData::upCast(::RdbRealData::RdbRealDataRespond* p) { return p; }

namespace
{
const ::std::string __RdbRealData__RdbRealDataRespond_ids[2] =
{
    "::Ice::Object",
    "::RdbRealData::RdbRealDataRespond"
};

}

bool
RdbRealData::RdbRealDataRespond::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__RdbRealData__RdbRealDataRespond_ids, __RdbRealData__RdbRealDataRespond_ids + 2, _s);
}

::std::vector< ::std::string>
RdbRealData::RdbRealDataRespond::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__RdbRealData__RdbRealDataRespond_ids[0], &__RdbRealData__RdbRealDataRespond_ids[2]);
}

const ::std::string&
RdbRealData::RdbRealDataRespond::ice_id(const ::Ice::Current&) const
{
    return __RdbRealData__RdbRealDataRespond_ids[1];
}

const ::std::string&
RdbRealData::RdbRealDataRespond::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::RdbRealData::RdbRealDataRespond";
    return typeId;
#else
    return __RdbRealData__RdbRealDataRespond_ids[1];
#endif
}

::Ice::DispatchStatus
RdbRealData::RdbRealDataRespond::___RespondDefaultData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::RespondDefaultDataSeq __p_seq;
    __is->read(__p_seq);
    __inS.endReadParams();
    RespondDefaultData(__p_seq, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbRealDataRespond::___RespondSpecificData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::RespondSpecficDataSeq __p_seq;
    __is->read(__p_seq);
    __inS.endReadParams();
    RespondSpecificData(__p_seq, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbRealDataRespond::___RespondCompleteData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::RespondCompleteDataSeq __p_seq;
    __is->read(__p_seq);
    __inS.endReadParams();
    RespondCompleteData(__p_seq, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbRealDataRespond::___SendTopoDataRespond(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::ReceiveTopoDataSeq __p_seq;
    __is->read(__p_seq);
    __inS.endReadParams();
    SendTopoDataRespond(__p_seq, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __RdbRealData__RdbRealDataRespond_all[] =
{
    "RespondCompleteData",
    "RespondDefaultData",
    "RespondSpecificData",
    "SendTopoDataRespond",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
RdbRealData::RdbRealDataRespond::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__RdbRealData__RdbRealDataRespond_all, __RdbRealData__RdbRealDataRespond_all + 8, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __RdbRealData__RdbRealDataRespond_all)
    {
        case 0:
        {
            return ___RespondCompleteData(in, current);
        }
        case 1:
        {
            return ___RespondDefaultData(in, current);
        }
        case 2:
        {
            return ___RespondSpecificData(in, current);
        }
        case 3:
        {
            return ___SendTopoDataRespond(in, current);
        }
        case 4:
        {
            return ___ice_id(in, current);
        }
        case 5:
        {
            return ___ice_ids(in, current);
        }
        case 6:
        {
            return ___ice_isA(in, current);
        }
        case 7:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
RdbRealData::RdbRealDataRespond::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
RdbRealData::RdbRealDataRespond::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
RdbRealData::__patch(RdbRealDataRespondPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::RdbRealData::RdbRealDataRespondPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::RdbRealData::RdbRealDataRespond::ice_staticId(), v);
    }
}

::Ice::Object* RdbRealData::upCast(::RdbRealData::RdbDataOpt* p) { return p; }

namespace
{
const ::std::string __RdbRealData__RdbDataOpt_ids[2] =
{
    "::Ice::Object",
    "::RdbRealData::RdbDataOpt"
};

}

bool
RdbRealData::RdbDataOpt::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__RdbRealData__RdbDataOpt_ids, __RdbRealData__RdbDataOpt_ids + 2, _s);
}

::std::vector< ::std::string>
RdbRealData::RdbDataOpt::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__RdbRealData__RdbDataOpt_ids[0], &__RdbRealData__RdbDataOpt_ids[2]);
}

const ::std::string&
RdbRealData::RdbDataOpt::ice_id(const ::Ice::Current&) const
{
    return __RdbRealData__RdbDataOpt_ids[1];
}

const ::std::string&
RdbRealData::RdbDataOpt::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::RdbRealData::RdbDataOpt";
    return typeId;
#else
    return __RdbRealData__RdbDataOpt_ids[1];
#endif
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___InsertData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::RespondCompleteDataSeq __p_dataSeq;
    __is->read(__p_dataSeq);
    __inS.endReadParams();
    ::RdbRealData::RespondCompleteDataSequence __p_errorSeq;
    bool __ret = InsertData(__p_dataSeq, __p_errorSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_errorSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___SelectDefaultData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::RequestDefaultDataSeq __p_reqSeq;
    __is->read(__p_reqSeq);
    __inS.endReadParams();
    ::RdbRealData::RespondDefaultDataSeq __p_repSeq;
    bool __ret = SelectDefaultData(__p_reqSeq, __p_repSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_repSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___SelectSpecificData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::RequestSpecficDataSeq __p_reqSeq;
    __is->read(__p_reqSeq);
    __inS.endReadParams();
    ::RdbRealData::RespondSpecficDataSeq __p_repSeq;
    bool __ret = SelectSpecificData(__p_reqSeq, __p_repSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_repSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___SelectCompleteData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::RequestCompleteDataSeq __p_reqSeq;
    __is->read(__p_reqSeq);
    __inS.endReadParams();
    ::RdbRealData::RespondCompleteDataSeq __p_repSeq;
    bool __ret = SelectCompleteData(__p_reqSeq, __p_repSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_repSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___BatchSelectCompleteData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::BatchRequestCompleteDataSeq __p_reqSeq;
    __is->read(__p_reqSeq);
    __inS.endReadParams();
    ::RdbRealData::RespondCompleteDataSeq __p_repSeq;
    bool __ret = BatchSelectCompleteData(__p_reqSeq, __p_repSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_repSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___SelectDataWithCondition(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::RequestConditionSequence __p_reqSeq;
    __is->read(__p_reqSeq);
    __inS.endReadParams();
    ::RdbRealData::RespondCompleteDataSeq __p_repSeq;
    bool __ret = SelectDataWithCondition(__p_reqSeq, __p_repSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_repSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___SelectDataCount(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::RequestDefaultDataSeq __p_reqSeq;
    __is->read(__p_reqSeq);
    __inS.endReadParams();
    ::RdbRealData::RespondDataCountSequence __p_repSeq;
    bool __ret = SelectDataCount(__p_reqSeq, __p_repSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_repSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___UpdateCompleteData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::RespondCompleteDataSeq __p_reqSeq;
    __is->read(__p_reqSeq);
    __inS.endReadParams();
    ::RdbRealData::RespondCompleteDataSequence __p_repSeq;
    bool __ret = UpdateCompleteData(__p_reqSeq, __p_repSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_repSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___DeleteRdbData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::RequestDefaultDataSeq __p_dataSeq;
    __is->read(__p_dataSeq);
    __inS.endReadParams();
    ::RdbRealData::RequestDefaultDataSequence __p_errorSeq;
    bool __ret = DeleteRdbData(__p_dataSeq, __p_errorSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_errorSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___GetEquipTree(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_deviceType;
    ::std::string __p_deviceRid;
    __is->read(__p_deviceType);
    __is->read(__p_deviceRid);
    __inS.endReadParams();
    ::RdbRealData::EquipTreeSequence __p_treeSeq;
    bool __ret = GetEquipTree(__p_deviceType, __p_deviceRid, __p_treeSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_treeSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___GetSpecificEquipTree(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_deviceType;
    ::std::string __p_deviceRid;
    ::std::string __p_specDeviceType;
    __is->read(__p_deviceType);
    __is->read(__p_deviceRid);
    __is->read(__p_specDeviceType);
    __inS.endReadParams();
    ::RdbRealData::EquipTreeSequence __p_treeSeq;
    bool __ret = GetSpecificEquipTree(__p_deviceType, __p_deviceRid, __p_specDeviceType, __p_treeSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_treeSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___GetEquipLineAndStationInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_deviceType;
    ::std::string __p_deviceRid;
    __is->read(__p_deviceType);
    __is->read(__p_deviceRid);
    __inS.endReadParams();
    ::RdbRealData::LineAndStationInfo __p_info;
    bool __ret = GetEquipLineAndStationInfo(__p_deviceType, __p_deviceRid, __p_info, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_info);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___isOrphanNode(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_dataType;
    ::std::string __p_dataRid;
    __is->read(__p_dataType);
    __is->read(__p_dataRid);
    __inS.endReadParams();
    bool __ret = isOrphanNode(__p_dataType, __p_dataRid, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___isEmptyNode(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_dataType;
    ::std::string __p_dataRid;
    __is->read(__p_dataType);
    __is->read(__p_dataRid);
    __inS.endReadParams();
    bool __ret = isEmptyNode(__p_dataType, __p_dataRid, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___IsInvalidDbData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_tableName;
    ::std::string __p_dataRID;
    __is->read(__p_tableName);
    __is->read(__p_dataRID);
    __inS.endReadParams();
    bool __ret = IsInvalidDbData(__p_tableName, __p_dataRID, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___GetTopoData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::RequestTopoDataSeq __p_inDataSeq;
    __is->read(__p_inDataSeq);
    __inS.endReadParams();
    ::RdbRealData::ReceiveTopoDataSeq __p_outDataSeq;
    bool __ret = GetTopoData(__p_inDataSeq, __p_outDataSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_outDataSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___GetTopoIslandInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::RdbRealData::TopoIslandInfoSeq __p_islandInfoes;
    GetTopoIslandInfo(__p_islandInfoes, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_islandInfoes);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___UpdateTopoData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    UpdateTopoData(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___GetSectionData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_deviceRid;
    __is->read(__p_deviceRid);
    __inS.endReadParams();
    ::RdbRealData::DoubleSeq __p_analogValues;
    ::RdbRealData::IntegerSeq __p_discreteValues;
    bool __ret = GetSectionData(__p_deviceRid, __p_analogValues, __p_discreteValues, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_analogValues);
    __os->write(__p_discreteValues);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___GetAllSectionData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_deviceRid;
    __is->read(__p_deviceRid);
    __inS.endReadParams();
    ::RdbRealData::SectionValueSeq __p_analogValues;
    ::RdbRealData::IntegerSeq __p_discreteValues;
    bool __ret = GetAllSectionData(__p_deviceRid, __p_analogValues, __p_discreteValues, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_analogValues);
    __os->write(__p_discreteValues);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___updateBreaker(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_mrid;
    ::RdbRealData::FieldMap __p_fieldData;
    __is->read(__p_mrid);
    __is->read(__p_fieldData);
    __inS.endReadParams();
    bool __ret = updateBreaker(__p_mrid, __p_fieldData, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___updateDisconnector(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_mrid;
    ::RdbRealData::FieldMap __p_fieldData;
    __is->read(__p_mrid);
    __is->read(__p_fieldData);
    __inS.endReadParams();
    bool __ret = updateDisconnector(__p_mrid, __p_fieldData, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___updatePowerTransformer(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_mrid;
    ::RdbRealData::FieldMap __p_fieldData;
    __is->read(__p_mrid);
    __is->read(__p_fieldData);
    __inS.endReadParams();
    bool __ret = updatePowerTransformer(__p_mrid, __p_fieldData, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___updateAnalog(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_mrid;
    ::RdbRealData::FieldMap __p_fieldData;
    __is->read(__p_mrid);
    __is->read(__p_fieldData);
    __inS.endReadParams();
    bool __ret = updateAnalog(__p_mrid, __p_fieldData, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___updateDiscrete(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_mrid;
    ::RdbRealData::FieldMap __p_fieldData;
    __is->read(__p_mrid);
    __is->read(__p_fieldData);
    __inS.endReadParams();
    bool __ret = updateDiscrete(__p_mrid, __p_fieldData, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___updateAccumulator(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_mrid;
    ::RdbRealData::FieldMap __p_fieldData;
    __is->read(__p_mrid);
    __is->read(__p_fieldData);
    __inS.endReadParams();
    bool __ret = updateAccumulator(__p_mrid, __p_fieldData, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___updateRemoteUnit(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_mrid;
    ::RdbRealData::FieldMap __p_fieldData;
    __is->read(__p_mrid);
    __is->read(__p_fieldData);
    __inS.endReadParams();
    bool __ret = updateRemoteUnit(__p_mrid, __p_fieldData, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::___getCurvePointDataSeq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbRealData::Strings __p_analogs;
    __is->read(__p_analogs);
    __inS.endReadParams();
    ::RdbRealData::CurvePointDataSeq __p_dataSeq;
    bool __ret = getCurvePointDataSeq(__p_analogs, __p_dataSeq, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_dataSeq);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __RdbRealData__RdbDataOpt_all[] =
{
    "BatchSelectCompleteData",
    "DeleteRdbData",
    "GetAllSectionData",
    "GetEquipLineAndStationInfo",
    "GetEquipTree",
    "GetSectionData",
    "GetSpecificEquipTree",
    "GetTopoData",
    "GetTopoIslandInfo",
    "InsertData",
    "IsInvalidDbData",
    "SelectCompleteData",
    "SelectDataCount",
    "SelectDataWithCondition",
    "SelectDefaultData",
    "SelectSpecificData",
    "UpdateCompleteData",
    "UpdateTopoData",
    "getCurvePointDataSeq",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "isEmptyNode",
    "isOrphanNode",
    "updateAccumulator",
    "updateAnalog",
    "updateBreaker",
    "updateDisconnector",
    "updateDiscrete",
    "updatePowerTransformer",
    "updateRemoteUnit"
};

}

::Ice::DispatchStatus
RdbRealData::RdbDataOpt::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__RdbRealData__RdbDataOpt_all, __RdbRealData__RdbDataOpt_all + 32, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __RdbRealData__RdbDataOpt_all)
    {
        case 0:
        {
            return ___BatchSelectCompleteData(in, current);
        }
        case 1:
        {
            return ___DeleteRdbData(in, current);
        }
        case 2:
        {
            return ___GetAllSectionData(in, current);
        }
        case 3:
        {
            return ___GetEquipLineAndStationInfo(in, current);
        }
        case 4:
        {
            return ___GetEquipTree(in, current);
        }
        case 5:
        {
            return ___GetSectionData(in, current);
        }
        case 6:
        {
            return ___GetSpecificEquipTree(in, current);
        }
        case 7:
        {
            return ___GetTopoData(in, current);
        }
        case 8:
        {
            return ___GetTopoIslandInfo(in, current);
        }
        case 9:
        {
            return ___InsertData(in, current);
        }
        case 10:
        {
            return ___IsInvalidDbData(in, current);
        }
        case 11:
        {
            return ___SelectCompleteData(in, current);
        }
        case 12:
        {
            return ___SelectDataCount(in, current);
        }
        case 13:
        {
            return ___SelectDataWithCondition(in, current);
        }
        case 14:
        {
            return ___SelectDefaultData(in, current);
        }
        case 15:
        {
            return ___SelectSpecificData(in, current);
        }
        case 16:
        {
            return ___UpdateCompleteData(in, current);
        }
        case 17:
        {
            return ___UpdateTopoData(in, current);
        }
        case 18:
        {
            return ___getCurvePointDataSeq(in, current);
        }
        case 19:
        {
            return ___ice_id(in, current);
        }
        case 20:
        {
            return ___ice_ids(in, current);
        }
        case 21:
        {
            return ___ice_isA(in, current);
        }
        case 22:
        {
            return ___ice_ping(in, current);
        }
        case 23:
        {
            return ___isEmptyNode(in, current);
        }
        case 24:
        {
            return ___isOrphanNode(in, current);
        }
        case 25:
        {
            return ___updateAccumulator(in, current);
        }
        case 26:
        {
            return ___updateAnalog(in, current);
        }
        case 27:
        {
            return ___updateBreaker(in, current);
        }
        case 28:
        {
            return ___updateDisconnector(in, current);
        }
        case 29:
        {
            return ___updateDiscrete(in, current);
        }
        case 30:
        {
            return ___updatePowerTransformer(in, current);
        }
        case 31:
        {
            return ___updateRemoteUnit(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
RdbRealData::RdbDataOpt::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
RdbRealData::RdbDataOpt::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
RdbRealData::__patch(RdbDataOptPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::RdbRealData::RdbDataOptPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::RdbRealData::RdbDataOpt::ice_staticId(), v);
    }
}

::Ice::Object* RdbWarningData::upCast(::RdbWarningData::RdbAlarmData* p) { return p; }

namespace
{
const ::std::string __RdbWarningData__RdbAlarmData_ids[2] =
{
    "::Ice::Object",
    "::RdbWarningData::RdbAlarmData"
};

}

bool
RdbWarningData::RdbAlarmData::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__RdbWarningData__RdbAlarmData_ids, __RdbWarningData__RdbAlarmData_ids + 2, _s);
}

::std::vector< ::std::string>
RdbWarningData::RdbAlarmData::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__RdbWarningData__RdbAlarmData_ids[0], &__RdbWarningData__RdbAlarmData_ids[2]);
}

const ::std::string&
RdbWarningData::RdbAlarmData::ice_id(const ::Ice::Current&) const
{
    return __RdbWarningData__RdbAlarmData_ids[1];
}

const ::std::string&
RdbWarningData::RdbAlarmData::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::RdbWarningData::RdbAlarmData";
    return typeId;
#else
    return __RdbWarningData__RdbAlarmData_ids[1];
#endif
}

::Ice::DispatchStatus
RdbWarningData::RdbAlarmData::___SendAlarmData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbWarningData::WarningInfoSeq __p_seq;
    __is->read(__p_seq);
    __inS.endReadParams();
    SendAlarmData(__p_seq, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __RdbWarningData__RdbAlarmData_all[] =
{
    "SendAlarmData",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
RdbWarningData::RdbAlarmData::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__RdbWarningData__RdbAlarmData_all, __RdbWarningData__RdbAlarmData_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __RdbWarningData__RdbAlarmData_all)
    {
        case 0:
        {
            return ___SendAlarmData(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
RdbWarningData::RdbAlarmData::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
RdbWarningData::RdbAlarmData::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
RdbWarningData::__patch(RdbAlarmDataPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::RdbWarningData::RdbAlarmDataPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::RdbWarningData::RdbAlarmData::ice_staticId(), v);
    }
}

::Ice::Object* RdbWarningData::upCast(::RdbWarningData::RdbAllAlarmData* p) { return p; }

namespace
{
const ::std::string __RdbWarningData__RdbAllAlarmData_ids[2] =
{
    "::Ice::Object",
    "::RdbWarningData::RdbAllAlarmData"
};

}

bool
RdbWarningData::RdbAllAlarmData::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__RdbWarningData__RdbAllAlarmData_ids, __RdbWarningData__RdbAllAlarmData_ids + 2, _s);
}

::std::vector< ::std::string>
RdbWarningData::RdbAllAlarmData::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__RdbWarningData__RdbAllAlarmData_ids[0], &__RdbWarningData__RdbAllAlarmData_ids[2]);
}

const ::std::string&
RdbWarningData::RdbAllAlarmData::ice_id(const ::Ice::Current&) const
{
    return __RdbWarningData__RdbAllAlarmData_ids[1];
}

const ::std::string&
RdbWarningData::RdbAllAlarmData::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::RdbWarningData::RdbAllAlarmData";
    return typeId;
#else
    return __RdbWarningData__RdbAllAlarmData_ids[1];
#endif
}

::Ice::DispatchStatus
RdbWarningData::RdbAllAlarmData::___SendAllAlarmData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbWarningData::WarningInfoSeq __p_seq;
    __is->read(__p_seq);
    __inS.endReadParams();
    SendAllAlarmData(__p_seq, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __RdbWarningData__RdbAllAlarmData_all[] =
{
    "SendAllAlarmData",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
RdbWarningData::RdbAllAlarmData::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__RdbWarningData__RdbAllAlarmData_all, __RdbWarningData__RdbAllAlarmData_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __RdbWarningData__RdbAllAlarmData_all)
    {
        case 0:
        {
            return ___SendAllAlarmData(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
RdbWarningData::RdbAllAlarmData::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
RdbWarningData::RdbAllAlarmData::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
RdbWarningData::__patch(RdbAllAlarmDataPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::RdbWarningData::RdbAllAlarmDataPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::RdbWarningData::RdbAllAlarmData::ice_staticId(), v);
    }
}

::Ice::Object* RdbWarningData::upCast(::RdbWarningData::RdbWarningBuf* p) { return p; }

namespace
{
const ::std::string __RdbWarningData__RdbWarningBuf_ids[2] =
{
    "::Ice::Object",
    "::RdbWarningData::RdbWarningBuf"
};

}

bool
RdbWarningData::RdbWarningBuf::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__RdbWarningData__RdbWarningBuf_ids, __RdbWarningData__RdbWarningBuf_ids + 2, _s);
}

::std::vector< ::std::string>
RdbWarningData::RdbWarningBuf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__RdbWarningData__RdbWarningBuf_ids[0], &__RdbWarningData__RdbWarningBuf_ids[2]);
}

const ::std::string&
RdbWarningData::RdbWarningBuf::ice_id(const ::Ice::Current&) const
{
    return __RdbWarningData__RdbWarningBuf_ids[1];
}

const ::std::string&
RdbWarningData::RdbWarningBuf::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::RdbWarningData::RdbWarningBuf";
    return typeId;
#else
    return __RdbWarningData__RdbWarningBuf_ids[1];
#endif
}

::Ice::DispatchStatus
RdbWarningData::RdbWarningBuf::___SendOutAnalogWarningBufs(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbWarningData::OutAnalogWarningBufSeq __p_seq;
    __is->read(__p_seq);
    __inS.endReadParams();
    SendOutAnalogWarningBufs(__p_seq, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbWarningData::RdbWarningBuf::___SendChangedUnitWarningBufs(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbWarningData::ChangedUnitWarningBufSeq __p_seq;
    __is->read(__p_seq);
    __inS.endReadParams();
    SendChangedUnitWarningBufs(__p_seq, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RdbWarningData::RdbWarningBuf::___SendChangedChannelWarningBufs(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::RdbWarningData::ChangedChannelWarningBufSeq __p_seq;
    __is->read(__p_seq);
    __inS.endReadParams();
    SendChangedChannelWarningBufs(__p_seq, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __RdbWarningData__RdbWarningBuf_all[] =
{
    "SendChangedChannelWarningBufs",
    "SendChangedUnitWarningBufs",
    "SendOutAnalogWarningBufs",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
RdbWarningData::RdbWarningBuf::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__RdbWarningData__RdbWarningBuf_all, __RdbWarningData__RdbWarningBuf_all + 7, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __RdbWarningData__RdbWarningBuf_all)
    {
        case 0:
        {
            return ___SendChangedChannelWarningBufs(in, current);
        }
        case 1:
        {
            return ___SendChangedUnitWarningBufs(in, current);
        }
        case 2:
        {
            return ___SendOutAnalogWarningBufs(in, current);
        }
        case 3:
        {
            return ___ice_id(in, current);
        }
        case 4:
        {
            return ___ice_ids(in, current);
        }
        case 5:
        {
            return ___ice_isA(in, current);
        }
        case 6:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
RdbWarningData::RdbWarningBuf::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
RdbWarningData::RdbWarningBuf::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
RdbWarningData::__patch(RdbWarningBufPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::RdbWarningData::RdbWarningBufPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::RdbWarningData::RdbWarningBuf::ice_staticId(), v);
    }
}
